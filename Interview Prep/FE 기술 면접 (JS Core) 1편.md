# 프론트엔드 기술 면접 (JS Core) 1편

### 1. 브라우저의 주소창에 `https://www.naver.com`을 입력하고, 엔터를 누르면?

1. 인터넷 상에서 데이터를 주고 받으려면, **상대방의 IP 주소**를 알아야 한다.
2. DNS 캐시에서 호스트 이름, `www.naver.com`을 탐색한다.
    - 실패할 경우, **DNS 서버**에서 호스트 이름과 연결된 **IP 주소**를 탐색한다.
3. ARP 프로토콜을 통해, 서버의 IP 주소를 기반으로 **MAC 주소**를 알아낸다.
4. 서버와 TCP 연결 생성을 위한 **3-Way-Handshake**를 수행한다.
5. 서버 측으로 **HTTP GET Request를 전송**한다.
    - 루트 URL이므로, `index.html`을 요청하게 된다.
6. 서버는 `443번 포트`를 통해 클라이언트의 **HTTP GET Request를 수신**한다. 
7. 서버는 필요한 처리를 수행하고, **HTTP Response**를 만들어 전송한다.
8. 클라이언트는 HTTP Response를 수신하고, TCP 연결을 종료한다.
    - TCP 종료는 4-Way-Handshake 과정을 통해 수행된다.
9. 브라우저는 수신된 HTTP Response Body에서 `index.html`을 확인한다.
10. 렌더링 엔진이 `index.html` 파일을 파싱하여 **DOM 트리 구조**를 만든다.
    - `<link>`, `<style>` 태그를 만나면 일시 중단한다.
        - 서버에 문서를 요청하고, CSS 문서를 파싱해 **CSSOM 트리 구조**를 만든다.
    - `<script>` 태그를 만나면 일시 중단 한다.
        - 서버에 문서를 요청하고, 자바스크립트 엔진에 제어권을 넘긴다.
        - 자바스크립트 엔진은 코드를 파싱해 바이트 코드를 생성한다.
        - 자바스크립트 코드가 평가되고, 실행된다.
11. DOM, CSSOM 트리가 완성되면, 이를 기반으로 **렌더 트리**를 만든다.
    - `<meta>` 등의 요소 노드는 포함되지 않는다.
    - `display: none` 속성을 가진 노드는 포함되지 않는다.
12. 렌더 트리를 기반으로 **레이아웃을 계산**하고, 브라우저 화면에 **렌더링**한다.

<br>

### 2. HTTP와 HTTPS 프로토콜의 차이는?

- HTTP는 평문을 전송하고, HTTPS는 암호문을 전송한다.
- HTTP는 TCP 프로토콜과 직접 통신하며, HTTPS는 SSL/TLS를 거친다.
- HTTP는 빠르고, HTTPS는 느리다.
    - 모든 경로에 HTTPS를 적용하는 것은 좋지 않을 수 있다.
- HTTP는 기본적으로 80번 포트를 사용하고, HTTPS는 443번 포트를 사용한다.

> SSL/TLS는 응용 계층과 전송 계층 사이에 별도의 계층을 생성한다.

<br>

### 3. 객체지향 프로그래밍(OOP)의 네가지 속성은?

- 추상화
    - 실세계의 복잡한 개념을 관심있는 부분만 남겨, 단순한 객체로 만드는 것이다.
    - (ex) 지구를 추상화하여, 지구본을 만든다.
- 캡슐화
    - 객체의 상태를 나타내는 프로퍼티, 객체의 상태를 조작하는 메서드를 하나로 묶는다.
    - 외부 접근을 막아 객체의 결합도를 낮출 수 있다.
    - (ex) 자판기에서 내부 동작을 감추고, 사용자 인터페이스만 노출한다.
- 상속
    - 객체의 프로퍼티와 메서드를 자식 객체가 그대로 사용할 수 있다.
- 다형성
    - 같은 메서드라도 인수의 개수와 종류에 따라 다르게 동작할 수 있다.
    - 오버라이딩, 오버로딩을 통해 이루어진다.

<br>

### 4. 함수형 프로그래밍은?

부수 효과를 발생시키지 않는 순수함수를 사용하며, 조건문과 반복문을 제거해 복잡성을 해결하고, 변수의 사용을 억제해 상태 변경을 최소화하는 프로그래밍 패러다임이다.

- 순수 함수란, 같은 입력에 대해 항상 같은 출력을 반환하는 함수이다.
    - 또한, 부수 효과를 유발하지 않는다.

- 부수 효과란, 함수의 실행에 의해 함수 외부의 상태가 변경되는 것을 말한다.
    - 상태를 예측하기 어렵게 만든다.

<br>

### 5. AJAX란?

> AJAX는 브라우저의 비동기 Web API인 `XMLHttpRequest` 객체를 기반으로 동작한다.

기존의 웹 페이지 동작 방식은, 페이지가 전환될 때마다 서버에 새로운 페이지를 요청하여 전체 페이지를 다시 렌더링하는 방식이었다. 이런 방식은 다음과 같은 단점을 가진다.

- 매번 전체 페이지를 다시 요청하므로, 불필요한 데이터가 중복되어 전송된다.
- 전체 페이지를 다시 렌더링 하므로, 전환 시 화면에 깜빡임이 발생한다.
- 동기적으로 요청을 수행하므로, 요청이 수행되는 동안 다른 작업을 수행할 수 없다.

이런 단점을 해결하기 위해 등장한 것이 AJAX로, 서버에 데이터를 비동기 방식으로 요청하며, 웹 페이지를 동적으로 렌더링할 수 있도록 합니다.

- 변경이 필요한 데이터만 요청하므로, 불필요한 데이터 전송이 없다.
- 처음부터 다시 렌더링하지 않고 DOM을 조작하므로, 화면이 깜빡이지 않는다.
- 서버로의 요청이 비동기 방식으로 처리되어, 다른 작업이 블로킹되지 않는다.

<br>

### 6. Callback 패턴이란?

> 콜백 함수 자체는 고차 함수에 매개변수를 통해 전달되는 함수를 말한다.

자바스크립트에서 비동기 작업을 수행하기 위해 사용되는 패턴입니다. 

비동기 함수의 내부에 있는 비동기 코드는, 비동기 함수가 콜 스택에서 실행될 때 완료되지 않으며, 비동기 함수가 종료된 이후의 시점에서 실행되고 결과를 반환합니다.

이렇게 반환되는 결과는 이미 비동기 함수가 종료되어 외부에서 처리할 수 없으며, 반드시 비동기 함수 내부에서 후속 조치가 진행되어야 합니다.

이런 상황에서 콜백 함수를 사용해 비동기 코드 실행 결과에 대한 처리를 진행할 수 있으며, 이는 자바스크립트 엔진과 별개의 장소에 존재하는 태스크 큐와 이벤트 루프에 의해 수행됩니다.

하지만 콜백 패턴은 다음과 같은 단점을 가집니다.

- 중첩되어 사용되는 경우 콜백 헬이 발생해, 가독성이 좋지 않다.
- `try-catch`를 이용한 에러 처리가 불가능하며, 에러 처리가 쉽지 않다.
- 다수의 비동기 처리를 한 번에 묶어서 처리하기 힘들다.

<br>

### 7. Promise란?

자바스크립트에서 비동기 처리를 수행하기 위해 사용하던 콜백 패턴의 단점을 개선하기 위해 ES6에서 새롭게 제안된 방식이다.

- Promise 역시 콜백 함수를 사용하며, `resolve`, `reject`를 인수로 전달받는다.
- Promise가 생성되고 반환되면, `Pending` 상태가 되어 비동기 처리 결과를 기다린다.
    - `resolve`가 호출되면, `Fulfilled` 상태로 전이한다.
    - `reject`가 호출되면, `Rejected` 상태로 전이한다.
- Promise가 `Settled` 상태가 되면, 상태에 따라 후속 조치 메서드가 호출된다.
    - `Fulfilled` 상태인 경우, `then()`이 호출된다.
    - `Rejected` 상태인 경우, `catch()`가 호출된다.
    - Promise 상태에 상관없이, `finally()`는 단 한번만 호출된다.

Promise를 사용하면 다음과 같은 장점이 있다.

- Promise를 이용하면, 체이닝을 이용해 콜백 헬에 의한 가독성 저하를 개선할 수 있다.
- 후속 조치 메서드를 이용해 에러 처리를 편리하게 수행할 수 있다.
- Promise 정적 메서드를 이용해 여러 개의 비동기 처리를 묶어서 처리할 수 있다.
    - `Promise.all`, `Promise.race`, `Promise.allSettled` 메서드를 사용한다.
    - 비동기 처리가 순차적으로 수행되는 경우에는 적용할 수 없다.

> 모든 후속 처리 메서드는 암묵적으로 Promise를 반환한다.

<br>

### 8. async, await은?

Proimise 기반으로 작동하며, 비동기 함수가 마치 동기 함수처럼 동작할 수 있도록 한다.

- `async` 키워드로 선언된 함수는 Promise를 반환한다.
    - `await` 키워드는 반드시 `async` 함수 내부에서 사용되어야 한다.
    - `await` 키워드는 반드시 Promise 앞에서 사용되어야 한다.
- `await` 키워드가 사용된 코드는, Promise가 `Settled` 상태로 변경될 때까지 대기한다.
    - 즉, `async` 함수의 코드 실행 흐름이 진행되지 않고 일시 중지된다.
    - Promise가 `Settled` 상태로 변경되면, 결과가 변수에 할당된다.

`async`, `await` 키워드를 사용하면 비동기 코드를 마치 동기 코드처럼 작성할 수 있지만, 에러 처리를 위해 `try-catch` 구문을 사용해야 한다.

<br>

### 9. 자바스크립트의 데이터 타입?

자바스크립트의 데이터는 크게 **원시 타입**과 **객체 타입**으로 나뉘며, 총 7가지의 데이터 타입을 지원한다.

- 원시 타입 (불변, Immutable)
    - Number
    - String
    - Boolean
    - Null
    - Undefined
    - Symbol (ES6)
    - 메모리에 저장된 값을 변경할 수 없다, 재할당은 가능하다. 
- 객체 타입 (가변, Mutable)
    - 원시 타입을 제외한 모든 데이터
    - 배열, 객체, 함수 등...
    - 메모리에 저장된 값을 변경할 수 있으며, 재할당도 가능하다.

> Null 타입은 개발자에 의해 **빈 값을 표현**하기 위해 사용되며, Undefined 타입은 자바스크립트 엔진에 의해 사용된다. 두 타입을 혼용해서 사용하지 않아야 한다.

<br>

### 10. 실행 컨텍스트란?

실행 컨텍스트는 자바스크립트 코드가 실행되는 환경을 제공하고, 실행 순서를 관리한다.

- 실행 순서는 실행 컨텍스트 스택에 의해 관리된다.
    - 스택의 최상위에 위치한 실행 컨텍스트가 **실행중인 실행 컨텍스트**이다.

- 스코프와 식별자는 렉시컬 환경에 의해 관리된다.
    - **환경 레코드**와 **외부 렉시컬 환경 참조**에 의해 스코프 체인이 구현된다.

- 전역 코드는 전역 실행 컨텍스트를, 함수는 함수 실행 컨텍스트를 생성한다.

- 전역 환경 레코드는 **객체 환경 레코드**와 **선언적 환경 레코드**로 구분되며, 오직 전역 실행 컨텐스트에서만 구분된다.
    - 객체 환경 레코드는 전역 코드 실행 전에 생성된 전역 객체를 가리킨다.
    - 선언적 환경 레코드는 `const`, `let` 키워드로 선언된 변수와 함수를 저장한다.

- 함수가 호출되면 함수 실행 컨텍스트가 생성된다.
    - 함수는 상위의 실행 컨텍스트에서 이미 평가되어, 함수 객체가 생성된 상태다.
        - `[[Environment]]` 내부 슬롯에서 해당 실행 컨텍스트를 참조한다.
    - 렉시컬 환경이 생성된다.
        - 환경 레코드에 매개변수, `arguments`, 지역변수가 저장된다.
        - 함수 호출 방식에 따라, `this` 바인딩이 결정된다.
        - 외부 렉시컬 환경에 대한 참조가 결정된다.
             - 함수 객체의 `[[Environment]]` 내부 슬롯을 따른다.
    - 함수가 종료되면 실행 컨텍스트가 소멸한다.
        - 렉시컬 환경이 반드시 함께 소멸하지는 않는다. 

<br>

### 11. 호이스팅이란?

자바스크립트의 모든 선언문은 마치 선언문이 속한 스코프의 최상단에 위치한 것처럼 동작하며, 이러한 현상을 호이스팅이라고 한다.

- 변수 호이스팅
    - 변수 선언문은 런타임 이전에 평가되어, **선언**과 **초기화** 단계가 수행된다.
    - 즉, 변수는 런타임 이전에 `undefined`로 초기화된다.
    - 따라서 런타임에서 변수 선언문 앞에서도 변수를 참조할 수 있다.

- 함수 호이스팅
    - 함수 선언문은 런타임 이전에 평가되어, 완전한 함수 객체가 생성된다.
    - 따라서 런타임에서 함수 선언문 앞에서도 함수를 호출할 수 있다.
    - 이때, 프로토타입 객체도 함께 생성된다.

- `const`, `let` 호이스팅
    - 런타임 이전에 평가되며, **변수 선언 단계**만 수행된다.
    - 즉, `undefined`로 초기화 되지 않는다.
    - 변수 초기화 단계는 런타임에서 변수 선언문에 도착하면 수행된다.
    - **일시적 사각 지대**가 생성되어, 변수 선언문 앞에서 변수를 참조할 수 없다. 


<br>

### 12. 클로저란?

중첩 함수가 외부 함수보다 오래 생존하며, 종료된 외부 함수에서 선언된 변수를 자유롭게 참조할 수 있는 경우, 클로저라고 부른다. 

- 즉, 클로저는 **자신이 생성된 렉시컬 환경**을 기억한다.
    - 자바스크립트의 스코프는 렉시컬 스코프이다.
    - 식별자는 자신이 선언된 위치에 의해 스코프가 결정된다.
- 실행 컨텍스트가 소멸해도, 렉시컬 환경은 해제되지 않을 수 있다.
    - 자바스크립트 가비지 컬렉터는 참조되고 있는 객체를 절대 해제하지 않는다.

자세한 클로저의 원리는 다음과 같다.

1. 전역 실행 컨텍스트에서 함수가 평가되어, 함수 객체가 생성된다.
    - `[[Environment]]` 내부 슬롯에 현재 실행 컨텍스트에 대한 참조가 저장된다.
2. 앞서 평가된 함수가 호출되고, 함수 실행 컨텍스트와 렉시컬 환경이 생성된다.
    - 내부의 중첩 함수를 평가해 함수 객체를 생성하고, 전역 스코프로 반환한다.
        - `[[Environment]]`에 현재 실행 컨텍스트에 대한 참조가 저장된다.
    - 함수가 종료되어 실행 컨텍스트는 소멸하지만, 렉시컬 환경은 소멸하지 않는다.
        - **반환된 함수의 함수 객체에 대한 참조가 존재**하기 때문이다.
3. 반환된 함수가 호출되면, 외부 렉시컬 환경 참조에 종료된 함수의 렉시컬 환경이 연결된다.
    - 내부 함수는 이미 종료된 외부 함수의 환경 레코드를 참조할 수 있다.

클로저를 사용하는 이유는 다음과 같다.

- 클로저는 상태를 안전하게 변경하고, 유지하기 위해 사용한다.
- `private` 접근 제어자를 구현하여, 정보를 은닉하기 위해 사용한다.

<br>

### 13. 프로토타입이란?

자바스크립트는 클래스를 사용하지 않는 프로토타입 기반의 객체지향 프로그래밍 언어로서, 프로토타입을 통해 상속을 구현한다.

- 모든 객체는 `[[Prototype]]` 내부 슬롯을 가진다.
    - `__proto__` 접근자 프로퍼티를 통해 간접적으로 접근할 수 있다.
    - `__proto__`는 `Object.Prototype`에서 상속 받은 것이다.

- `[[Construct]]` 내부 메서드를 가지는 함수는, `prototype` 프로퍼티를 가진다.
    - `prototype` 프로퍼티는 해당 함수가 생성할 인스턴스의 프로토타입이 된다.
    - 함수가 평가되는 시점에서, 프로토타입 객체가 함께 생성된다.

- 객체에서 프로퍼티에 접근할 때, `__proto__` 참조를 따라서 프로퍼티를 탐색한다.
    - 이것을 **프로토타입 체인**이라고 한다.
    - 식별자는 스코프 체인을 따라 탐색하며, 프로토타입 체인과 협력한다.
    - `Object.prototype`은 프로토타입 체인의 종점이다.

> 스코프 체인은 식별자 탐색을 위한 매커니즘, 프로토타입 체인은 객체의 프로퍼티를 검색하기 위한 매커니즘이다.

<br>

### 14. 일급객체?

다음의 조건을 만족하는 것을 일급 객체라고 한다.

1. 무명의 리터럴을 이용해, 런타임에서 생성할 수 있다.
2. 변수 및 자료구조(배열, 객체 등)에 저장할 수 있다.
3. 함수의 인수로 전달할 수 있다.
4. 함수에서 결과로 반환할 수 있다.

자바스크립트의 함수는 일급 객체이며, 따라서 고차함수를 통해 함수형 프로그래밍 패러다임을 적용할 수 있다.

> 고차함수란 함수를 인수로 받거나, 함수를 반환하는 함수를 말한다.

<br>

### 15. `this`는 무엇이며, 어떻게 변화하는가?

`this`는 **자기 참조 변수**이며, 객체에 속한 메서드가 자기자신의 프로퍼티를 변경할 때 자기 자신을 참조하기 위해 사용된다.

- `this`는 함수의 호출 방식에 따라 동적으로 결정된다.
    - 반면 스코프는 함수가 선언된 환경을 따르는, 렉시컬 스코프 방식으로 결정된다.

- 일반 함수 호출 시, `this`에는 전역 객체가 바인딩된다.
    - 중첩 함수, 콜백 함수에 관계없이 일반 함수 호출은 모두 해당된다.
    - `strict mode`에서는 `undefined`가 바인딩 된다.

- 메서드로 호출 시, 메서드를 호출한 객체가 바인딩 된다.
    - `me.method()`로 호출하면, `this`에는 `me`가 바인딩된다.
    - ES6 화살표 함수 메서드는 `this`가 없으므로, 전역 객체가 바인딩 된다.

- 생성자로 호출 시, 생성자가 생성할 인스턴스가 바인딩 된다.

- `Function.prototype`의 `call`, `apply`, `bind`를 통해 `this` 바인딩 할 수 있다.

<br>

### 16. 이벤트 루프

자바스크립트 엔진은 싱글 스레드로 동작하여, 한 번에 하나의 작업만 처리한다. 그러나 브라우저의 동작은 마치 다수의 작업이 동시에 처리되는 것처럼 보인다.

- 자바스크립트 엔진은 싱글 스레드로 동작하며, 동기 처리만 수행한다.
    - **콜 스택**과 **힙 영역**으로 구성된다.
    - 한 번에 하나의 작업만 수행할 수 있고, 다른 작업들은 대기한다.

- 비동기 처리는 브라우저 또는 Node.js가 담당한다.
    - **태스크 큐**와 **이벤트 루프**로 구성된다.
    - 태스크 큐에 비동기 함수의 콜백 함수와 이벤트 핸들러가 임시 저장된다.
    - 이벤트 루프는 콜 스택과 태스크 큐를 감시한다.
        - 콜 스택이 비어있다면, 태스크 큐에서 작업을 꺼내 콜 스택에 푸시한다.

예를 들어, `setTimeout()` 함수의 평가와 실행은 자바스크립트 엔진에서 수행하지만, 연관된 타이머 설정과 콜백 함수를 태스크 큐에 등록하는 것은 브라우저에 의해 수행된다.

<br>

### 17. 이벤트 버블링, 캡처링, 위임

DOM 요소에서 발생한 이벤트는 DOM 트리 구조를 따라 전파된다.

- 이벤트의 전파는 **캡처링, 타겟, 버블링 단계**를 통해 일어난다.
    - 캡처링 단계에서, `window`에서 이벤트 타겟으로 전파된다.
    - 타겟 단계에서, 이벤트가 이벤트 타겟에 도착한다.
    - 버블링 단계에서, 이벤트 타겟에서 `window`로 전파된다.

- 이벤트 핸들러는 기본적으로 **버블링 단계**의 이벤트를 캐치한다.
    - 어트리뷰트, 프로퍼티 이벤트 핸들러는 버블링 단계만 캐치할 수 있다.
    - `addEventListener` 방식은, 세번째 매개변수를 통해 캡처링 단계를 캐치할 수 있다.

- 이벤트 버블링을 활용하여, **이벤트 위임을 구현**할 수 있다.
    - 동적으로 DOM 요소가 생성되는 경우, 개별 이벤트 핸들러 등록이 어렵다.
    - 이벤트 위임을 통해, 개별 요소에 핸들러를 등록하지 않고도 이벤트를 캐치할 수 있다.

이벤트 전파는 `Event.stopPropagation()`을 통해 방지할 수 있다.

> 이벤트가 발생한 요소를 `target`이라고 하며, 이벤트 핸들러가 등록된 요소를 `currentTarget`이라고 한다.

<br>

### 18. CORS

CORS(Cross Origin Resource Sharing)은 출처가 다른, 즉 **도메인과 포트번호가 다른 서버의 자원을 요청**하는 행위을 의미한다.

그러나 대부분의 브라우저는 보안상의 이유로 SOP(Same Origin Policy), **동일 출처 정책**을 따르고 있기 때문에 기본적으로 **CORS는 브라우저에 의해 거부**당한다.

> 동일 출처 정책(Same Origin Policy)
>
> XSS, CSRF와 같은 보안 취약점 공격을 방지하기 위한 방식으로, 도메인 이름과 포트 번호가 동일하지 않은 서버에 대한 자원 요청을 거부한다. 

가장 쉬운 해결 방법은 **클라이언트와 서버가 동일한 도메인과 포트번호를 사용**하는 것이지만, 이것은 실제 어플리케이션에 적용 가능한 방법이 아니다.

서버에서 HTTP 응답을 생성할 때, `Access-Control-Allow-Origin` 헤더에 CORS를 허가할 클라이언트의 도메인 이름과 포트번호를 추가해주면 된다. 

- 브라우저는 본 요청을 전송하기에 앞서, `OPTIONS` 메서드를 이용해 서버에 접근한다.  
    - 이것을 `Preflight Request`라고 하며, 동일 출처 정책 위반 여부를 확인한다.
- 안전하다고 판단된 서버인 경우, 브라우저는 본 요청을 전송한다.
- 만약 안전하지 않은 서버인 경우, 브라우저는 `CORS Error`를 발생시킨다.
