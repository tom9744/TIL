# 2021 K사 코딩테스트 Review


## 1번 문제

`one`, `two` 등의 문자열과 `1`, `2` 같은 숫자가 섞인 문자열을 처리하는 문제.

1. 딕셔너리를 이용해, `key-value` 형태로 문자열과 숫자를 매핑했다.
    - 해시 테이블이므로, O(1)의 시간 복잡도로 접근할 수 있다.
    - `key`와 일치하는 경우, 즉시 `value`를 사용해 변환한다.
2. 문자열을 두 개의 포인터를 사용해 순회한다.
    - 숫자가 아닌 경우, 오른쪽 포인터를 증가시키며 딕셔너리를 조회한다.
    - 일치하는 `key`를 발견하면, 매핑된 `value`를 결과 배열에 추가한다.
    - 이후 왼쪽 포인터를 1 증가시키고, 순회를 계속 진행한다.
3. 결과 배열을 `join()` 메서드로 문자열으로 변환하고, `int()`로 숫자로 변환한다. 

### 해시 테이블?

- 해시 테이블은 `key-value`로 데이터를 저장하는 자료구조이다.
- **해시 함수**를 이용해 데이터를 숫자로 변환하고, 인덱스로 사용한다.
- 데이터에 접근하는데 소요되는 평균 시간복잡도는 O(1)이다.
    - 해시 함수의 성능에 따라, 시간복잡도가 O(N)까지 증가할 수 있다.
- 해시 충돌이 발생하면, `Seperate Chaining` 또는 `Open Addressing`으로 해결한다.
    - `Seperate Chaining`: 별도의 자료구조를 이용해, 중복된 데이터를 저장한다.
        - 데이터의 양이 많아지면 성능의 저하가 발생할 수 있다.
    - `Open Addressing`: 비어있는 해시 테이블 공간을 사용한다.
        - 선형 탐색법은, 현재 위치에서 한 칸씩 이동하며 빈 공간을 확인한다.
        - 데이터가 한 곳에 밀집되는 현상이 발생할 수 있다.
<br>

## 2번 문제

사무실 배치가 거리두기를 지키고 있는지, **2차원 배열을 탐색**하는 문제. 

1. 5x5 크기의 작은 2차원 배열이므로, DFS로 완전 탐색이 가능할 것이라 생각했다.
    - 사람이 위치한 모든 좌표에 대해, DFS 그래프 탐색을 수행한다.
    - 재귀 호출을 수행하며, 맨해튼 거리 `2`에 도달하면 멈춘다.
    - 이때, 방문처리를 통해 이미 방문한 노드를 다시 방문하지 않도록 해야한다.
2. 주어진 장소들의 거리두시 성공 여부를 `result = [1, 1, 1, 1, 1]`로 나타낸다.
    - 장소안의 모든 사람에 대해 DFS를 수행하고, 임시 배열에 결과를 저장한다.
    - `all()` 메서드를 사용해, 해당 장소의 거리두기 성공/실패 여부를 확인한다.
        - 거리두기에 성공한 경우, `result[idx] = 1` 
        - 거리두기에 실패한 경우, `result[idx] = 0`
3. `result` 배열을 그대로 반환한다.

### DFS/BFS?

- 깊이 우선 탐색
    - 도달할 수 있는 최대 깊이까지 먼저 방문한다.
    - **스택 자료구조**를 이용하며, 재귀적으로 구현할 수 있다.
    - 항상 최적의 해를 구하지는 못한다.

- 너비 우선 탐색
    - 같은 레벨에 있는 노드부터 먼저 방문한다.
    - **큐 자료구조**를 이용하며, 재귀적으로 구현할 수 없다.
    - 항상 최적의 해를 구할 수 있다.

### 개선 가능한 부분?

- DFS 알고리즘 수행 시, 노드 방문처리의 시간복잡도를 개선할 수 있다.
    - `(nx ny) not in visited` 부분에서 선형탐색을 수행하므로, O(N)이다.
    - 배열대신 **딕셔너리를 사용하면, 평균 O(1)에 접근**할 수 있다.
- 거리두기 성공 여부 확인 시, 조건문의 가독성을 개선할 수 있다.
    - 모든 경우를 하드코딩 방식으로 작성하여, 코드의 길이가 길어졌다.
    - `path not in ["OP", "PO", "PX", "PP"]`처럼 한 줄로 처리할 수 있다.

<br>

## 3번 문제

몇 가지 명령어와 데이터가 주어지면, 정해진 규칙에 따라 동작하도록 하는 문제.

1. 커서의 위/아래 이동은 두 개의 자료구조를 이용해 구현했다.
    - 커서의 전방은 스택, 후방은 데크를 사용했다.
    - 커서는 **스택의 마지막 요소를 가리키도록 구현**했다.
2. 삭제 명령이 주어지면, 스택에서 마지막 요소를 `pop()`한다.
    - 제거된 요소를 별도의 장소에 보관한다.
    - 커서 뒤쪽의 데크에 요소가 남아 있다면, 스택으로 가져온다.
3. 복구 명령이 주어지면, 제거된 요소를 보관하는 스택의 마지막 요소를 `pop()`한다.
    - 커서의 앞쪽, 뒤쪽 중 적합한 위치를 선택한다.
    - 이분 탐색을 사용해 O(logN) 시간복잡도로 삽입 위치를 찾는다.
    - [문제 발생] `insert()` 메서드로 제거되었던 요소를 복구한다.
        - 배열의 `insert()` 메서드는 시간복잡도가 O(N)이다.

### 개선 가능한 부분?

- 우선, 데크를 굳이 사용할 필요가 없었다고 생각한다.
    - 스택으로 사용해도 된다.
- 제거한 요소를 탐색하는 부분에서 시간초과가 발생한다고 생각한다.
    - 삽입 위치 탐색에 O(logN), 삽입에 O(N)이 소요된다.
    - 양방향 연결리스트를 사용하면 탐색 및 삽입에 O(N)이므로 해결할 수 있다.
    - 문제에서 `X`의 총합이 1,000,000 이하라고 하였으므로 가능한 것이다.

<br>

## 4번 문제

방향 그래프에서 주어진 시작점에서 도착점으로 가기위한 최단 거리를 계산하는 문제.

> 다만, 함정을 밟으면 모든 간선의 방향이 역전된다.

1. 최단 거리를 찾는 문제이므로, BFS 알고리즘으로 먼저 접근했다.
2. 정방향, 역방향으로 나누어 인접 리스트 형태로 그래프를 생성했다.
3. 현재 간선의 방향을 나타내는 플래그를 설정했다.
4. 함정을 밟으면 플래그의 방향이 바뀌고, 해당하는 방향 그래프를 사용하도록 했다.


### 개선 가능한 부분?

- 시험이 종료되고 함께 시험을 본 사람들에게 4번 문제 풀이를 문의했다.
    - 다익스트라 알고리즘이라는 의견이 많았다.
    - 다익스트라 알고리즘이 무엇인지는알지만, 문제를 많이 접해보지 못했다.
    - 시험 이후 BOJ에서 최단 거리를 구하는 문제를 여러개 풀어보았다.
        - 다익스트라 알고리즘을 공부했다.
        - 플로이드 워셜 알고리즘을 공부했다.

### 다익스트라?

다익스트라 알고리즘은 **가중치가 양수인 그래프**에서 최단거리를 찾는 알고리즘이다.

- 거리 테이블을 생성하고, 무한대로 초기화한다.
- 우선순위 큐를 생성하고, 시작노드를 비용 0으로 설정해 삽입한다.
    - 시작 노드를 거쳐, 연결된 노드로 이동하는 비용을 계산해본다.
    - 현재 거리 테이블의 값보다 작다면 갱신한다.
    - 갱신한 경우, 갱신된 값으로 새롭게 우선순위 큐에 추가한다.
- 우선순위 큐에서 한 번 꺼낸 노드의 최단거리는, 확정된 최단거리이다.
- 시간 복잡도는 O(ElogV)이다.  