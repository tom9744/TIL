# 프론트엔드 기술 면접 (JS Core) 2편

### 1. 엄격 모드

ES5에서 등장한 개념으로, 보다 엄격한 기준으로 자바스크립트 코드를 평가하여 기존에 에러를 발생시키지 않던 코드에 대해 에러를 발생시킨다.

- 선언되지 않은 변수를 참조하면 전역 객체에 등록되지 않고, 에러가 발생한다.
- 중복된 매개변수 이름을 사용할 수 없고, 에러가 발생한다.
- 일반 함수 호출 시, `this`에 `undefined`가 바인딩된다.
- `arguments` 객체를 수정할 수 없다.
- ES6 이상의 문법의 내부에서는 기본값으로 엄격 모드가 사용된다.

<br>

### 2. 디바운싱 / 스로틀링

디바운싱과 스로틀링은 `scroll`, `resize`, `input`과 같이 짧은 시간동안 연속적으로 발생하는 이벤트를 효과적으로 다루기 위한 방법이다.

- 디바운싱
    - 일정 시간 내에 발생한 모든 이벤트를, 맨 마지막에 단 한번만 처리한다.
    - `input` 이벤트를 다루기 적합하다.

- 스로틀링
    - 연속적으로 발생하는 이벤트를, 일정한 간격으로 계속해서 처리한다.
    - `scroll` 이벤트를 다루기 적합하다.

<br>

### 3. 이벤트 핸들러 추가 방식 차이

- 이벤트 어트리뷰트 방식
    - 단 하나의 이벤트 핸들러만 등록할 수 있다.
    - 이벤트 **버블링 단계**만 캐치할 수 있다.
    - `thos`에 전역 객체가 바인딩 된다.

- 이벤트 프로터피 방식
    - 단 하나의 이벤트 핸들러만 등록할 수 있다.
    - 이벤트 **버블링 단계**만 캐치할 수 있다.
    - `this`에 핸들러가 등록된 DOM이 바인딩 된다. 

- `addEventListener` 방식
    - 단일 이벤트에 대해, 다수의 핸들러를 등록할 수 있다.
    - 이벤트 캡처링, 버블링 단계를 모두 캐치할 수 있다.
        - 기본값은 버블링 단계를 캐치한다.
        - 세번째 매개변수로 `true`를 전달하면 캡처링 단계를 캐치한다. 
    - `this`에 핸들러가 등록된 DOM이 바인딩 된다. 

<br>

### 4. Rest 파라미터, Spread 문법

- Rest 파라미터
    - 여러 요소의 목록을 묶어, 하나의 배열을 만든다.
    - **가변 인수 함수**를 작성하기 위해 사용한다.

- Spread 문법
    - 배열, 유사 배열 객체를 여러 요소의 목록으로 분해한다.
    - **배열이나 객체의 복사본**을 생성하기 위해 사용한다.
    - 결과로 반환된느 것은 값이 아니므로, 변수에 할당할 수 없다.

<br>

### 5. `async`, `defer`

`<script>` 태그에 `async` 또는 `defer` 어트리뷰트를 추가하면, 브라우저의 렌더링 엔진이 HTML 문서를 파싱해 DOM을 생성하는 과정에서 `<script>` 태그를 만나도 DOM 생성을 일시 중단하지 않는다.

- `async`
    - 자바스크립트 파일의 로딩이 비동기적으로 수행된다.
    - 자바스크립트 파일의 로딩이 완료되면, 자바스크립트 코드를 실행한다.
        - 자바스크립트 코드의 실행 순서가 보장되지 않는다.
    - DOM 조작이 포함된 코드인 경우, 에러를 발생시킬 가능성이 있다.

- `defer`
    - 자바스크립트 파일의 로딩이 비동기적으로 수행된다.
    - 자바스크립트 파일의 로딩이 완료되어도, HTML 문서 파싱을 대기한다.
        - DOM 생성까지 완료되면, 자바스크립트 코드를 실행한다.
    - DOM 생성이 완료되어, DOM 조작을 자유롭게 수행할 수 있다.

`async`와 `defer`는 HTML 문서를 파싱하는 과정에서 `<script>` 태그를 만나도 자바스크립트 파일 로딩을 위해 DOM 생성을 중단하지 않고 비동기적으로 자바스크립트 파일을 다운로드 받는다. 하지만, **로딩이 완료된 후 자바스크립트 코드를 실행하는 시점에서 차이**가 존재한다.

> 인라인 스크립트 태그 `<script> ... </script>` 에 대해서는 `async`, `defer` 어트리뷰트가 적용되지 않으며, 따라서 HTML 문서의 파싱을 멈추고 즉시 자바스크립트 코드를 실행한다.

<br>

### 6. `<script>` 태그 위치

개발자가 원하는 어느 위치에도 배치할 수 있지만, DOM에 접근하는 자바스크립트 코드가 포함된 경우, `<body>` 태그의 맨 하단에 배치하는 것이 현명하다.

- HTML 문서 파싱이 중단되기 때문에, 사용자는 빈 화면을 보게된다.
    - DOM 트리의 생성이 완료되지 않아, 렌더 트리가 생성되지 못한다.
    - 부드러운 사용자 경험을 제공할 수 없다.
- HTML 문서 파싱이 중단되기 때문에, 접근할 DOM이 생성되지 않았을 수 있다.
    - DOM을 참조할 수 없어, 에러가 발생할 수 있다.

<br>

### 7. `var` 변수와 `const`, `let` 변수의 차이?

- `var` 변수
    - **함수 레벨 스코프**를 따른다.
    - 전역 변수로 사용 시, **전역 객체의 프로퍼티로 등록**된다. 
    - **중복 선언이 가능**하다.
        - 암묵적으로 `var` 키워드가 제거된 것처럼 동작한다. 
    - 호이스팅 되어, **선언문 이전에서 참조 가능**하다.
        - 런타임 이전에 **선언, 초기화 단계**가 진행된다.
        - `undefined`로 초기화 된다.

- `const`, `let` 변수는 **블록 레벨 스코프**를 따른다.
    - **블록 레벨 스코프**를 따른다.
    - 전역 변수로 사용 시, 전역 객체의 프로퍼티로 등록되지 않는다.
    - **중복 선언이 불가능**하다.
    - 호이스팅 되지만, 선언문 이전에 참조할 수 없다.
        - 런타임 이전에 **선언 단계**만 진행된다.
        - **초기화 단계**는 런타임에서, 변수 선언문에 도착하면 진행된다.

<br>

### 8. 고차 함수란?

> 자바스크립트의 함수는 일급 객체이며, 함수에 인수로 전달하거나 함수 실행 결과로 반환될 수 있다.

- **함수를 인수로 전달 받거나, 함수를 반환하는 함수**를 고차함수라고 한다.
- `Array.prototype`은 다양한 고차함수를 제공한다.
- 함수형 프로그래밍에서 순수 함수, 보조 함수와 함께 사용된다.

<br>

### 9. 화살표 함수의 차이점?

- 화살표 함수는 자체적인 `this` 바인딩을 가지지 않는다.
    - 스코프 체인을 따라, 상위 스코프의 `this` 바인딩을 사용한다.
    - `call`, `apply`, `bind`로 `this` 바인딩을 변경할 수 없다.
    - 더불어 `arguments`, `constructor`, `super`도 가지지 않는다.
- 화살표 함수는 `[[Construct]]` 내부 메서드가 존재하지 않는다.
    - `non-constructor` 함수이다.
    - `prototype` 프로퍼티가 존재하지 않으며, 프로토타입 객체도 없다.
    - 따라서, `new` 키워드를 사용해 생성자로 호출할 수 없다.
- 화살표 함수는 **콜백 함수에서 `this` 바인딩이 불일치**하는 문제를 해결한다.
    - 콜백 함수가 일반 함수로 호출되면, `this`에 전역객체가 바인딩 된다.
 
<br>

### 10. 동등 연산자(`==`)와 일치 연산자(`===`)의 차이?

- 동등 비교 연산자, `==`는 **값의 일치 여부를 확인**한다.
    - 두 피연산자의 타입이 다른 경우, **암묵적 타입 변환**을 수행한다.
    - 숫자 `1`과  문자열 `'1'`은 값이 같으므로, `true`로 평가한다. 

- 일치 비교 연산자, `===`는 **값과 타입의 일치 여부를 확인**한다.
    - **암묵적 타입 변환**을 수행하지 않는다.
    - 숫자 `1`과  문자열 `'1'`은 타입이 다르므로, `false`로 평가한다. 

동등 비교 연산자는 어플리케이션의 동작을 예상하기 어렵게 하므로, 특수한 상황이 아닌 경우 되도록 사용하지 않는 것이 좋다.

<br>

### 11. 쿠키, 로컬 스토리지, 세션 스토리지

HTML5에서 클라이언트에 데이터를 저장할 수 있는 Web Storage가 포함되었고, `LocalStorage`와 `SessionStorage`가 대표적이다.


- 쿠키(Cookie)
    - 무상태성 HTTP 프로토콜에서, 클라이언트를 기억하기 위해 사용된다.
    - 쿠키는 HTTP 응답의 `Set-Cookie` 헤더를 통해, 서버에 의해 설정된다.
        - 클라이언트는 `Cookie` 헤더를 통해, 쿠키를 매번 서버로 전송한다.
    - 쿠키는 4KB의 제한된 용량만 보관할 수 있다.
    - 쿠키는 유효 기간이 존재하며, 기간이 만료되면 삭제된다.
    - 쿠키는 `XSS`, `CSRF` 공격에 취약하다.
    - **세션 기반 로그인**을 구현하는데 사용된다.
        - 클라이언트는 서버 접속 시, 세션 ID를 발급 받는다.
        - 클라이언트는 세션 ID를 쿠키에 저장하고, 매번 서버에 전달한다.
        - 서버는 수신한 세션 ID를 확인하고, 세션에 저장된 데이터를 제공한다.

> 세션 방식은 모든 데이터를 서버에 보관하여 비교적 안전하지만, 서버의 자원을 많이 사용하게 된다는 점에서 비용적인 문제가 발생할 수 있다. 

- 웹 스토리지(Web Storage)
    - HTML5에서 추가된 새로운 형태의 클라이언트 데이터 저장소이다.
    - Key-Value 형태로 데이터를 저장한다.
    - 쿠키와 달리, 암묵적으로 HTTP 요청 헤더에 포함되지 않는다.
        - 서버로 전송 여부를 선택할 수 있다.
    - 최대 5MB 용량을 보관할 수 있다.
    - 유효 기간이 존재하지 않는다.

- 로컬 스토리지(Local Storage)
    - 브라우저를 종료해도 데이터가 유지되는 저장소이다.
    - 도메인 별로 생성되며, 다른 도메인의 로컬 스토리지는 접근할 수 없다.
    - 영속적으로 필요한 데이터를 저장하기 위해 사용된다.
        - JWT Token

- 세션 스토리지(Session Storage)
    - 브라우저를 종료하면 데이터가 삭제된다.
    - 중요한 데이터는 영속적으로 보관하지 않고, 세션 스토리지를 사용한다.

<br>

### 12. REST API는 무엇인가?

서버 자원의 위치를 나타내는 URI를 설계하기 위한 아키텍처 중 하나이다.

- URI는 자원을 나타낸다.
    - **명사 형태**를 사용해야 하며, 동사를 사용하지 않는다.
- HTTP 메서드로 자원에 대한 동작을 나타낸다.
    - `GET`
    - `POST`
    - `PUT`
    - `PATH`
    - `DELETE`

이러한 API 설계 원칙에 따라 작성된 것을 **RESTful API**라고 부른다.

<br>

### 13. 타입스크립트 사용의 장/단점?

자바스크립트는 동적 타이핑 언어로, 변수에 할당한 값에 의해 데이터 타입이 결정된다. 또한 컴파일되지 않고 즉시 실행되는 인터프리터 언어이기 때문에, **대부분의 에러가 런타임에서 발생**한다.

- 타입스크립트를 사용하면, 동적 타이핑 언어의 장점을 그대로 얻는다.
    - 에러 및 버그에 강인한 코드를 작성할 수 있다.
    - 코드의 동작을 쉽게 예측할 수 있다.
    - 대부분의 에러를 컴파일 타임에 해결해, 런타임 에러가 줄어든다.
    - 코드의 가독성을 개선할 수 있다.

- 부수적인 장점
    - `tsconfig.json`에서 다양한 설정값을 변경해 사용자화 할 수 있다.
